<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>ThanksForAllTheFish</title>
    <link rel="stylesheet" href="/assets/styles/katex/katex.min.css">
    <link rel="stylesheet" href="/assets/styles/hljs/github.css">
    <link rel="stylesheet" href="/assets/styles/page.css">
</head>

<body>
    <div id="main">
        <div id="navigator"><ul><li><a href="/contents/00-posts.html" class="navigator-link-active">posts</a></li><li><a href="/contents/01-about.html">about</a></li></ul></div>
        <div id="content-wrapper">
            <div id="content"><blockquote>
<p><strong>DISCLAIMER:</strong> The idea of this blog is mine but LLM wrote most of the text. I have read and adjusted the content to make sure it aligned with my intention.</p>
</blockquote>
<p>The <strong>Entity-Component-System (ECS)</strong> pattern, widely used in game development and simulations, cleanly separates data (components), identities (entities), and logic (systems). Kubernetes — while may not explicitly designed using ECS — mirrors this architecture in its resource management model. This blog explores how Kubernetes objects, state configurations, and control loops map to ECS principles, revealing insights into Kubernetes’ declarative design.</p>
<table>
<thead>
<tr>
<th><strong>ECS</strong></th>
<th><strong>Kubernetes</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Entity</strong></td>
<td>Kubernetes Object (Pod, Deployment, etc.)</td>
<td>A unique, identifiable resource. Identified by <code>metadata.name</code> (namespace-unique) and <code>metadata.uid</code> (cluster-wide unique UUID).</td>
</tr>
<tr>
<td><strong>Component</strong></td>
<td><code>spec</code> and <code>status</code> Sections</td>
<td>- <code>spec</code>: User-defined (user can be another system) desired state. <br> - <code>status</code>: System-generated observed state. <br> Additional components: <code>metadata.labels</code>, <code>annotations</code>.</td>
</tr>
<tr>
<td><strong>System</strong></td>
<td>Controllers, Scheduler, Kubelet</td>
<td>Processes that watch and reconcile differences between <code>spec</code> (desired) and <code>status</code> (actual).</td>
</tr>
</tbody></table>
<p><em>Since <a href="https://www.usenix.org/publications/loginonline/prodspec-and-annealing-intent-based-actuation-google-production">Prodspec and Annealing</a> is at least partially inspired by Entity-Component systems, the architecture similarity could be intentional.</em></p>
<hr>
<h3>1. Entity ↔ Kubernetes Object</h3>
<p>In ECS, <strong>entities</strong> are abstract objects (e.g., a &quot;player&quot;) identified by a unique ID. In Kubernetes, every resource (Pod, Deployment, Ingress) acts as an entity:</p>
<ul>
<li><strong><code>metadata.name</code></strong>: A human-readable identifier (unique within a resource type and namespace).</li>
<li><strong><code>metadata.uid</code></strong>: A globally unique UUID auto-generated by Kubernetes (e.g., <code>5e6c906e-2e49-11ef-8a7f-0242ac1a0003</code>).</li>
</ul>
<p>Kubernetes objects are inert — they hold state but lack behavior. Their lifecycle is managed externally by <strong>systems</strong> (controllers).</p>
<hr>
<h3>2. Component ↔ Spec, Status, and Metadata</h3>
<p><strong>Components</strong> in ECS attach data to entities (e.g., &quot;health&quot; component storing hit points). In Kubernetes, structured configurations fill this role:</p>
<h4>Types of &quot;Components&quot;:</h4>
<ul>
<li><p><strong><code>spec</code></strong>:
The <strong>desired state</strong> declared by users. For example:</p>
<ul>
<li><strong>Deployment</strong>: <code>spec.replicas=3</code> demands three Pod instances.</li>
<li><strong>Pod</strong>: <code>spec.containers[].image</code> defines the container image to run.</li>
</ul>
</li>
<li><p><strong><code>status</code></strong>:
The <strong>observed state</strong> managed by Kubernetes subsystems. For example:</p>
<ul>
<li><strong>Deployment</strong>: <code>status.availableReplicas=3</code> signals all Pods are running.</li>
<li><strong>Node</strong>: <code>status.conditions[].ready=true</code> confirms node health.</li>
</ul>
</li>
<li><p><strong>Metadata (Labels/Annotations)</strong>:
Key-value pairs acting as passive components for identification (<code>app: frontend</code>) or tooling-configuration (<code>kubernetes.io/ingress-class: nginx</code>).</p>
</li>
</ul>
<p>Components drive automation by decoupling <em>intent</em> (spec) from <em>reality</em> (status).</p>
<hr>
<h3>3. System ↔ Controllers, Schedulers, and Agents</h3>
<p><strong>Systems</strong> in ECS process entities with specific components (e.g., a &quot;movement system&quot; updates positions). Kubernetes controllers and agents behave analogously:</p>
<p>In ECS, <strong>systems</strong> are processes that act on entities with specific components to perform logic (e.g., a &quot;physics system&quot; updates positions for entities with &quot;velocity&quot; components). Kubernetes implements this concept through its <strong>control plane components</strong> — controllers, schedulers, and agents — that monitor entities (resources) and reconcile their components (<code>spec</code> and <code>status</code>).</p>
</div>
        </div>
    </div>
</body>

</html>